<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tron Lightcycles — Neon Classic</title>
<style>
  body { 
    margin: 0; 
    overflow: hidden; 
    background: linear-gradient(120deg, #000, #111); 
    font-family: 'Orbitron', sans-serif; 
    text-align: center; 
    color: #0ff; 
  }
  canvas { 
    display: block; 
    margin: 0 auto; 
    background-color: #000; 
    border: 4px solid #0ff; 
    box-shadow: 0 0 20px #0ff inset;
  }
  #menu { 
    position: absolute; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    color: #0ff; 
    text-shadow: 0 0 10px #0ff; 
  }
  button { 
    font-size: 20px; 
    padding: 12px 25px; 
    margin: 10px; 
    cursor: pointer; 
    border: 2px solid #0ff; 
    border-radius: 12px; 
    background: linear-gradient(45deg,#000,#111); 
    color: #0ff; 
    font-weight: bold; 
    text-shadow: 0 0 5px #0ff; 
    transition: 0.3s; 
  }
  button:hover { 
    background: #0ff; 
    color: #000; 
    box-shadow: 0 0 15px #0ff; 
  }
  #score { 
    position: absolute; 
    top: 10px; 
    width: 100%; 
    text-align: center; 
    font-size: 24px; 
    color: #0ff; 
    text-shadow: 0 0 10px #0ff; 
    letter-spacing: 1px;
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
<div id="score">Player 1: 0  |  Player 2: 0</div>
<div id="menu">
  <h1>Tron Lightcycles ⚡ Neon</h1>
  <button id="botBtn">1 Player (vs Smart Bot)</button>
  <button id="twoBtn">2 Player</button>
  <button id="restartBtn">Restart</button>
</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const cellSize = 10;
const cols = canvas.width / cellSize;
const rows = canvas.height / cellSize;
let gameInterval;
let mode = 'bot';
let scores = {p1:0, p2:0};

const player1 = {x: 10, y: 10, dx:1, dy:0, color:'#0ff', trail:[]};
const player2 = {x: cols-10, y: rows-10, dx:-1, dy:0, color:'#f0f', trail:[]};
const maxTrailLength = 1000;

function resetGame(){
  player1.x=10; player1.y=10; player1.dx=1; player1.dy=0; player1.trail=[];
  player2.x=cols-10; player2.y=rows-10; player2.dx=-1; player2.dy=0; player2.trail=[];
  document.getElementById('menu').style.display='none';
}

function drawCell(x,y,color){
  ctx.shadowColor = color;
  ctx.shadowBlur = 20;
  ctx.fillStyle=color;
  ctx.fillRect(x*cellSize,y*cellSize,cellSize,cellSize);
  ctx.shadowBlur=0;
}

function drawGrid(){
  ctx.strokeStyle='rgba(0,255,255,0.05)';
  ctx.lineWidth=1;
  for(let i=0;i<=cols;i++){ctx.beginPath();ctx.moveTo(i*cellSize,0);ctx.lineTo(i*cellSize,canvas.height);ctx.stroke();}
  for(let i=0;i<=rows;i++){ctx.beginPath();ctx.moveTo(0,i*cellSize);ctx.lineTo(canvas.width,i*cellSize);ctx.stroke();}
}

function checkCollisionAt(pos){
  if(pos.x<0||pos.x>=cols||pos.y<0||pos.y>=rows) return true;
  for(let t of player1.trail.concat(player2.trail)) if(t.x===pos.x&&t.y===pos.y) return true;
  return false;
}

function update(){
  if(mode==='bot') smartBotMove();

  const next1 = { x: player1.x + player1.dx, y: player1.y + player1.dy };
  const next2 = { x: player2.x + player2.dx, y: player2.y + player2.dy };

  // head-to-head collision
  if(checkCollisionAt(next1) || checkCollisionAt(next2) || (next1.x===next2.x && next1.y===next2.y)){
    handleCrash();
    return;
  }

  player1.trail.push({x:player1.x,y:player1.y});
  player2.trail.push({x:player2.x,y:player2.y});

  if(player1.trail.length>maxTrailLength) player1.trail.shift();
  if(player2.trail.length>maxTrailLength) player2.trail.shift();

  player1.x = next1.x; player1.y = next1.y;
  player2.x = next2.x; player2.y = next2.y;

  draw();
}

function draw(){
  // semi-transparent background for smooth fading trails
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  drawGrid();

  player1.trail.forEach(t => drawCell(t.x,t.y,player1.color));
  player2.trail.forEach(t => drawCell(t.x,t.y,player2.color));

  drawCell(player1.x,player1.y,player1.color);
  drawCell(player2.x,player2.y,player2.color);
}

function handleCrash(){
  clearInterval(gameInterval);
  const p1Dead = checkCollisionAt({x:player1.x,y:player1.y});
  const p2Dead = checkCollisionAt({x:player2.x,y:player2.y});
  let winner='Draw!';
  if(p1Dead && !p2Dead) {winner='Player 2 Wins!'; scores.p2++;}
  else if(p2Dead && !p1Dead) {winner='Player 1 Wins!'; scores.p1++;}
  document.getElementById('score').textContent=`Player 1: ${scores.p1}  |  Player 2: ${scores.p2}`;
  ctx.fillStyle='#0ff'; ctx.font='60px Orbitron'; ctx.textAlign='center';
  ctx.fillText(winner,canvas.width/2,canvas.height/2);
  document.getElementById('menu').style.display='block';
}

// Smart Bot AI
const DIRS=[{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}];
function dirIndex(dx,dy){for(let i=0;i<4;i++) if(DIRS[i].dx===dx&&DIRS[i].dy===dy) return i; return 0;}
function neighbours(x,y){return [{x:x,y:y-1},{x:x+1,y:y},{x:x,y:y+1},{x:x-1,y:y}];}
function isOccupied(x,y){if(x<0||x>=cols||y<0||y>=rows) return true; for(const t of player1.trail) if(t.x===x&&t.y===y) return true; for(const t of player2.trail) if(t.x===x&&t.y===y) return true; if(player1.x===x&&player1.y===y) return true; if(player2.x===x&&player2.y===y) return true; return false;}
function floodAreaCount(sx,sy,limit=2000){if(isOccupied(sx,sy)) return 0; const q=[{x:sx,y:sy}]; const seen=new Set([sx+','+sy]); let count=0; while(q.length&&count<limit){const cur=q.shift(); count++; for(const n of neighbours(cur.x,cur.y)){const key=n.x+','+n.y; if(seen.has(key)) continue; if(n.x<0||n.x>=cols||n.y<0||n.y>=rows) continue; if(isOccupied(n.x,n.y)) continue; seen.add(key); q.push(n);}} return count;}
function smartBotMove(){
  let idx=dirIndex(player2.dx,player2.dy);
  const candIdx=[idx,(idx+3)%4,(idx+1)%4];
  const candidates=[];
  for(const ci of candIdx){
    const d=DIRS[ci];
    const nx=player2.x+d.dx; const ny=player2.y+d.dy;
    if(isOccupied(nx,ny)) continue;
    let area=floodAreaCount(nx,ny,2000);
    const dist=Math.abs(nx-player1.x)+Math.abs(ny-player1.y);
    area += (100-dist);
    candidates.push({d,area});
  }
  if(candidates.length===0) return;
  candidates.sort((a,b)=>b.area-a.area);
  const best=candidates[0];
  player2.dx=best.d.dx; player2.dy=best.d.dy;
}

// Input handling
document.addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  switch(k){
    case 'arrowup': if(player1.dy===0){player1.dx=0;player1.dy=-1;} break;
    case 'arrowdown': if(player1.dy===0){player1.dx=0;player1.dy=1;} break;
    case 'arrowleft': if(player1.dx===0){player1.dx=-1;player1.dy=0;} break;
    case 'arrowright': if(player1.dx===0){player1.dx=1;player1.dy=0;} break;
    case 'w': if(player2.dy===0){player2.dx=0;player2.dy=-1;} break;
    case 's': if(player2.dy===0){player2.dx=0;player2.dy=1;} break;
    case 'a': if(player2.dx===0){player2.dx=-1;player2.dy=0;} break;
    case 'd': if(player2.dx===0){player2.dx=1;player2.dy=0;} break;
  }
});

function startGame(selectedMode){
  mode=selectedMode;
  resetGame();
  clearInterval(gameInterval);
  gameInterval=setInterval(update,80);
}

document.getElementById('botBtn').addEventListener('click',()=>startGame('bot'));
document.getElementById('twoBtn').addEventListener('click',()=>startGame('two'));
document.getElementById('restartBtn').addEventListener('click',()=>startGame(mode));
</script>
</body>
</html>
